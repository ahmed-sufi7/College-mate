<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>PDA College 3D Map</title>
<link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet"/>
<style>
html,body{margin:0;height:100%;width:100%}
#map{
    position:absolute;
    top:0;
    bottom:0;
    width:100%}
#floors{
position:absolute;
top:10px;
left:10px;
z-index:1;
background:white; 
border-radius:6px;
padding:4px;
box-shadow:0 2px 6px rgba(0,0,0,0.3)
onclick=cursor;
}
.btn{
border:none;
margin:2px;
padding:6px 10px;
background:#007bff;
color:white;
border-radius:4px; 
cursor:pointer;
font-size:13px
}
.btn:hover{background:#a5d2e2}
</style>
</head>
<body>
<div id="floors">
<button class="btn" onclick="showFloor(1)">Floor 1</button>
<button class="btn" onclick="showFloor(2)">Floor 2</button>
<button class="btn" onclick="getUserLocation()">üìç My Location</button>
<input type="text" id="searchBox" placeholder="Search classes..." style="width: 180px; padding: 6px 10px; margin: 2px; border-radius: 4px; border: 1px solid #ccc; font-size: 13px;">
<div id="searchResults" style="margin-top: 8px; max-height: 200px; overflow-y: auto; background: white; border-radius: 4px; padding: 4px;"></div>
</div>
<div id="map"></div>
<script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
<script>
const map = new maplibregl.Map({
    container: 'map',
    style: {
        version: 8,
        sources: {
            'osm-tiles': {
                type: 'raster',
                tiles: [
                    'https://a.tile.openstreetmap.org/{z}/{x}/{y}.png',
                    'https://b.tile.openstreetmap.org/{z}/{x}/{y}.png',
                    'https://c.tile.openstreetmap.org/{z}/{x}/{y}.png'
                ],
                tileSize: 256,
                attribution: '¬© OpenStreetMap contributors'
            }
        },
        layers: [
            {
                id: 'osm-tiles',
                type: 'raster',
                source: 'osm-tiles',
                minzoom: 0,
                maxzoom: 19
            }
        ]
    },
    center: [76.8347, 17.3153],
    zoom: 18,
    pitch: 60,
    bearing: -20
});

// Load map.geojson and add its features
fetch('map.geojson')
  .then(response => response.json())
  .then(geojson => {
    // Convert ALL LineStrings to Polygons with same height
    const blockPolygons = geojson.features
      .filter(f => f.geometry.type === 'LineString')
      .map((f, i) => ({
        type: 'Feature',
        properties: { name: `Block ${i + 1}`, height: 10 },
        geometry: {
          type: 'Polygon',
          coordinates: [
            [...f.geometry.coordinates, f.geometry.coordinates[0]] // close the polygon
          ]
        }
      }));        const blocksGeojson = {
            type: 'FeatureCollection',
            features: blockPolygons
        };

        map.on('load', () => {
            // Add original GeoJSON source
            map.addSource('college-map', {
                type: 'geojson',
                data: geojson
            });

            // Add blocks source
            map.addSource('blocks', {
                type: 'geojson',
                data: blocksGeojson
            });

            // Add 3D blocks as fill-extrusion
            map.addLayer({
                id: '3d-blocks',
                type: 'fill-extrusion',
                source: 'blocks',
                paint: {
                    'fill-extrusion-color': '#007bff',
                    'fill-extrusion-height': ['get', 'height'],
                    'fill-extrusion-opacity': 0.85
                }
            });

            // Add LineString features as lines
            map.addLayer({
                id: 'lines',
                type: 'line',
                source: 'college-map',
                filter: ['==', ['geometry-type'], 'LineString'],
                paint: {
                    'line-color': '#007bff',
                    'line-width': 4
                }
            });

            // Add Point features as circles
            map.addLayer({
                id: 'points',
                type: 'circle',
                source: 'college-map',
                filter: ['==', ['geometry-type'], 'Point'],
                paint: {
                    'circle-radius': 8,
                    'circle-color': '#ff5722',
                    'circle-stroke-width': 2,
                    'circle-stroke-color': '#fff'
                }
            });

            // Add popups for points with properties
            geojson.features.forEach(f => {
                if (f.geometry.type === 'Point' && f.properties && Object.keys(f.properties).length) {
                    new maplibregl.Popup({ closeButton: false, closeOnClick: false })
                        .setLngLat(f.geometry.coordinates)
                        .setHTML(`<b>${Object.keys(f.properties)[0]}</b><br>${Object.values(f.properties)[0]}`)
                        .addTo(map);
                }
            });

            // Store geojson for search functionality
            window.allGeojson = geojson;
        });
    });

// Search functionality
document.getElementById('searchBox').addEventListener('input', function(e) {
  const query = e.target.value.toLowerCase();
  const resultsDiv = document.getElementById('searchResults');
  resultsDiv.innerHTML = '';

  if (!window.allGeojson || query.length === 0) {
    return;
  }

  const pointFeatures = window.allGeojson.features.filter(f => f.geometry.type === 'Point');
  const matches = pointFeatures.filter(f => {
    const props = f.properties || {};
    const propsText = Object.keys(props).concat(Object.values(props)).join(' ').toLowerCase();
    return propsText.includes(query);
  });

  if (matches.length === 0) {
    resultsDiv.innerHTML = '<p style="padding: 8px; color: #999;">No results found</p>';
    return;
  }

  matches.forEach(match => {
    const props = match.properties || {};
    const className = Object.keys(props)[0] || 'Unknown';
    const description = Object.values(props)[0] || '';
    const resultItem = document.createElement('div');
    resultItem.style.cssText = 'padding: 8px; margin: 2px 0; background: #f0f0f0; border-radius: 4px; cursor: pointer; font-size: 12px;';
    resultItem.innerHTML = `<b>${className}</b>${description ? '<br><small style="color: #666;">' + description + '</small>' : ''}`;
    resultItem.onmouseover = () => resultItem.style.background = '#e0e0e0';
    resultItem.onmouseout = () => resultItem.style.background = '#f0f0f0';
    resultItem.onclick = () => {
      map.flyTo({
        center: match.geometry.coordinates,
        zoom: 19,
        duration: 1000
      });
      new maplibregl.Popup({ closeButton: true, closeOnClick: true })
        .setLngLat(match.geometry.coordinates)
        .setHTML(`<b>${className}</b>${description ? '<br>' + description : ''}`)
        .addTo(map);
    };
    resultsDiv.appendChild(resultItem);
  });
});

// User location functionality
let userLocationMarker = null;
let geolocationWatchId = null;
let accuracyCircle = null;

function getUserLocation() {
  if (!navigator.geolocation) {
    alert('Geolocation is not supported by your browser');
    return;
  }

  const btn = event.target;
  btn.disabled = true;
  btn.textContent = '‚è≥ Getting location...';

  // Get current position and then watch for continuous updates
  navigator.geolocation.getCurrentPosition(
    (position) => {
      displayUserLocation(position);
      btn.disabled = false;
      btn.textContent = 'üìç My Location';
      
      // Watch position for live updates
      if (geolocationWatchId) {
        navigator.geolocation.clearWatch(geolocationWatchId);
      }
      geolocationWatchId = navigator.geolocation.watchPosition(displayUserLocation);
    },
    (error) => {
      handleGeolocationError(error);
      btn.disabled = false;
      btn.textContent = 'üìç My Location';
    },
    { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
  );
}

function displayUserLocation(position) {
  const { latitude, longitude, accuracy } = position.coords;
  
  // Remove previous marker if exists
  if (userLocationMarker) {
    userLocationMarker.remove();
  }

  // Remove previous accuracy circle if exists
  if (accuracyCircle) {
    map.removeLayer('accuracy-circle');
    map.removeSource('accuracy-circle');
  }

  // Create custom marker element
  const el = document.createElement('div');
  el.style.cssText = 'width: 24px; height: 24px; background: #4285F4; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 8px rgba(66, 133, 244, 0.6);';
  
  // Add marker to map
  userLocationMarker = new maplibregl.Marker({ element: el, anchor: 'center' })
    .setLngLat([longitude, latitude])
    .addTo(map);

  // Draw accuracy radius circle
  const accuracyRadius = accuracy; // in meters
  const circlePoints = [];
  for (let i = 0; i <= 360; i += 10) {
    const latOffset = (accuracyRadius / 111320) * Math.cos((i * Math.PI) / 180);
    const lngOffset = (accuracyRadius / (111320 * Math.cos((latitude * Math.PI) / 180))) * Math.sin((i * Math.PI) / 180);
    circlePoints.push([longitude + lngOffset, latitude + latOffset]);
  }
  circlePoints.push(circlePoints[0]);

  map.addSource('accuracy-circle', {
    type: 'geojson',
    data: {
      type: 'Feature',
      geometry: { type: 'LineString', coordinates: circlePoints }
    }
  });

  map.addLayer({
    id: 'accuracy-circle',
    type: 'line',
    source: 'accuracy-circle',
    paint: { 'line-color': '#4285F4', 'line-width': 1, 'line-dasharray': [2, 2], 'line-opacity': 0.5 }
  });

  // Fly to user location
  map.flyTo({
    center: [longitude, latitude],
    zoom: 20,
    duration: 1000
  });

  // Show popup with location info
  new maplibregl.Popup({ closeButton: true, offset: [0, -30] })
    .setLngLat([longitude, latitude])
    .setHTML(`<b>Your Location</b><br>Lat: ${latitude.toFixed(5)}<br>Lng: ${longitude.toFixed(5)}<br>Accuracy: ¬±${accuracy.toFixed(0)}m`)
    .addTo(map);
}

function handleGeolocationError(error) {
  let errorMsg = 'Unable to get your location';
  if (error.code === error.PERMISSION_DENIED) {
    errorMsg = 'Location permission denied. Please enable location access in your browser settings.';
  } else if (error.code === error.POSITION_UNAVAILABLE) {
    errorMsg = 'Location information is unavailable.';
  } else if (error.code === error.TIMEOUT) {
    errorMsg = 'Location request timed out. Try again.';
  }
  alert(errorMsg);
  console.error('Geolocation error:', error);
}
</script>
</body>
</html>