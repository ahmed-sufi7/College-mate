<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PDA College 3D Map — 2 floors</title>
  <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
  <style>
    html,
    body {
      height: 100%;
      margin: 0;
      font-family: Arial, Helvetica, sans-serif
    }

    #map {
      position: absolute;
      inset: 0
    }

    #controls {
      position: absolute;
      left: 12px;
      top: 12px;
      z-index: 3;
      background: #fff;
      border-radius: 8px;
      padding: 10px;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.12);
      min-width: 260px;
    }

    .btn {
      display: inline-block;
      padding: 8px 10px;
      margin: 3px;
      border-radius: 6px;
      border: 0;
      cursor: pointer;
      font-size: 13px
    }

    .btn.primary {
      background: #0d6efd;
      color: #fff
    }

    .btn.ghost {
      background: #f1f3f5;
      color: #222
    }

    input[type="search"] {
      width: 100%;
      padding: 7px;
      border-radius: 6px;
      border: 1px solid #ddd;
      margin-top: 8px
    }

    #results {
      max-height: 220px;
      overflow: auto;
      margin-top: 8px
    }

    .result {
      padding: 8px;
      border-radius: 6px;
      margin: 6px 0;
      background: #fafafa;
      cursor: pointer
    }

    .result:hover {
      background: #f0f8ff
    }

    #legend {
      margin-top: 8px;
      font-size: 13px
    }

    #legend .row {
      display: flex;
      gap: 8px;
      align-items: center;
      margin: 6px 0
    }

    .sw {
      width: 18px;
      height: 12px;
      border-radius: 3px;
      display: inline-block
    }
  </style>
</head>

<body>
  <div id="controls">
    <div style="display:flex;gap:6px;align-items:center">
      <button id="btnF1" class="btn primary">Floor 1</button>
      <button id="btnF2" class="btn ghost">Floor 2</button>
      <button id="btnBoth" class="btn" style="background:#20c997;color:#fff">Show Both</button>
    </div>

    <input id="search" type="search" placeholder="Search rooms / points (e.g. LH-15, Cloud Computing)" />

    <div id="results"></div>

    <div id="legend">
      <div class="row"><span class="sw" style="background:#1f78b4"></span> Floor 1 (0 → 5 m)</div>
      <div class="row"><span class="sw" style="background:#33a02c"></span> Floor 2 (5 → 10 m)</div>
    </div>
  </div>

  <div id="map"></div>

  <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
  <script>
    // -----------------------------
    // Fetch GeoJSON files
    // -----------------------------
    let MAP = null;
    let FLOOR1 = null;
    let FLOOR2 = null;

    // Load all GeoJSON files
    Promise.all([
      fetch('map.geojson').then(r => r.json()),
      fetch('map2.geojson').then(r => r.json()),
      fetch('map1.geojson').then(r => r.json())
    ]).then(([mapData, floor1Data, floor2Data]) => {
      MAP = mapData;
      FLOOR1 = floor1Data;
      FLOOR2 = floor2Data;
      initializeMap();
    }).catch(err => {
      console.error('Error loading GeoJSON files:', err);
      alert('Failed to load map data. Please ensure map.geojson, map1.geojson, and map2.geojson files exist.');
    });

    // -----------------------------
    // Utility helpers
    // -----------------------------
    // compute a simple centroid from polygon rings (average of ring coordinates)
    function centroidOfPolygon(poly) {
      // poly: [ [ [lon,lat], ... ] ] (first ring)
      const ring = poly && poly[0] ? poly[0] : [];
      if (!ring.length) return null;
      let sumX = 0, sumY = 0;
      ring.forEach(pt => { sumX += pt[0]; sumY += pt[1]; });
      return [sumX / ring.length, sumY / ring.length];
    }

    // make a point feature for each polygon (for labels & flyTo)
    function polygonCentroidPoints(fc, nameProp = 'name') {
      const pts = { type: 'FeatureCollection', features: [] };
      fc.features.forEach((f, idx) => {
        if (!f.geometry) return;
        if (f.geometry.type !== 'Polygon') return;
        const c = centroidOfPolygon(f.geometry.coordinates);
        const label = (f.properties && (f.properties[nameProp] || f.properties.label || f.properties.name)) || ('room-' + idx);
        pts.features.push({
          type: 'Feature',
          geometry: { type: 'Point', coordinates: c },
          properties: { label, source_index: idx, original_props: f.properties || {} }
        });
      });
      return pts;
    }

    // Merge polygon features into a single geojson (and ensure each has a 'height' & 'floor' property)
    function prepareFloorPolys(fc, floorNumber) {
      const out = { type: 'FeatureCollection', features: [] };
      (fc.features || []).forEach(f => {
        const clone = JSON.parse(JSON.stringify(f));
        if (!clone.properties) clone.properties = {};
        // set uniform heights (Option A)
        if (floorNumber === 1) {
          clone.properties.floor = 1;
          clone.properties.height = 5;         // top
          clone.properties.base = 0;           // base
        } else {
          clone.properties.floor = 2;
          clone.properties.height = 10;        // top
          clone.properties.base = 5;           // base
        }
        out.features.push(clone);
      });
      return out;
    }

    // -----------------------------
    // Map initialization
    // -----------------------------
    function initializeMap() {
      const map = new maplibregl.Map({
        container: 'map',
        style: {
          version: 8,
          sources: {
            'osm-tiles': {
              type: 'raster',
              tiles: [
                'https://a.tile.openstreetmap.org/{z}/{x}/{y}.png',
                'https://b.tile.openstreetmap.org/{z}/{x}/{y}.png',
                'https://c.tile.openstreetmap.org/{z}/{x}/{y}.png'
              ],
              tileSize: 256
            }
          },
          layers: [{ id: 'osm-tiles', type: 'raster', source: 'osm-tiles' }]
        },
        center: [76.8342, 17.3154],
        zoom: 18,
        pitch: 60,
        bearing: -20
      });

      map.on('load', () => {
        // prepare floor GeoJSONs
        const floor1Polys = prepareFloorPolys(FLOOR1, 1);
        const floor2Polys = prepareFloorPolys(FLOOR2, 2);

        // polygon centroids for labels
        const floor1Points = polygonCentroidPoints(floor1Polys);
        const floor2Points = polygonCentroidPoints(floor2Polys);

        // add sources
        map.addSource('map-points', { type: 'geojson', data: MAP }); // raw points + lines
        map.addSource('floor1-polys', { type: 'geojson', data: floor1Polys });
        map.addSource('floor2-polys', { type: 'geojson', data: floor2Polys });
        map.addSource('floor1-points', { type: 'geojson', data: floor1Points });
        map.addSource('floor2-points', { type: 'geojson', data: floor2Points });

        // add outline lines from MAP (LineString features)
        map.addLayer({
          id: 'outlines',
          type: 'line',
          source: 'map-points',
          filter: ['==', ['geometry-type'], 'LineString'],
          paint: { 'line-color': '#003f7f', 'line-width': 2, 'line-opacity': 0.9 }
        });

        // Floor 1 extrusions
        map.addLayer({
          id: 'floor1-extrude',
          type: 'fill-extrusion',
          source: 'floor1-polys',
          paint: {
            'fill-extrusion-color': '#1f78b4',
            'fill-extrusion-height': ['get', 'height'],
            'fill-extrusion-base': ['get', 'base'],
            'fill-extrusion-opacity': 0.95
          }
        });

        // Floor 2 extrusions (hidden initially)
        map.addLayer({
          id: 'floor2-extrude',
          type: 'fill-extrusion',
          source: 'floor2-polys',
          layout: { visibility: 'none' },
          paint: {
            'fill-extrusion-color': '#33a02c',
            'fill-extrusion-height': ['get', 'height'],
            'fill-extrusion-base': ['get', 'base'],
            'fill-extrusion-opacity': 0.95
          }
        });

        // labels for floor1 (from centroid points)
        map.addLayer({
          id: 'floor1-labels',
          type: 'symbol',
          source: 'floor1-points',
          layout: {
            'text-field': ['coalesce', ['get', 'label'], ''],
            'text-size': 12,
            'text-anchor': 'top',
            'text-offset': [0, 1.0]
          },
          paint: { 'text-color': '#fff', 'text-halo-color': '#000', 'text-halo-width': 1 }
        });

        // labels for floor2 (hidden initially)
        map.addLayer({
          id: 'floor2-labels',
          type: 'symbol',
          source: 'floor2-points',
          layout: { 'text-field': ['coalesce', ['get', 'label'], ''], 'text-size': 12, 'text-anchor': 'top', 'text-offset': [0, 1.0] },
          paint: { 'text-color': '#fff', 'text-halo-color': '#000', 'text-halo-width': 1 },
          layout: { visibility: 'none' } // ensure labels hidden with floor
        });

        // points from MAP (original loose POIs)
        map.addLayer({
          id: 'map-poi-points',
          type: 'circle',
          source: 'map-points',
          filter: ['==', ['geometry-type'], 'Point'],
          paint: { 'circle-radius': 5, 'circle-color': '#ff7f00', 'circle-stroke-color': '#fff', 'circle-stroke-width': 1.5 }
        });

        // clickable highlight layer (single feature highlight)
        map.addSource('hover-highlight', { type: 'geojson', data: { type: 'FeatureCollection', features: [] } });
        map.addLayer({
          id: 'hover-highlight-fill',
          type: 'fill-extrusion',
          source: 'hover-highlight',
          paint: {
            'fill-extrusion-color': '#ff0000',
            'fill-extrusion-height': ['get', 'height'],
            'fill-extrusion-base': ['get', 'base'],
            'fill-extrusion-opacity': 0.6
          }
        });

        // bind interactivity: clicking on extrusions shows popup
        map.on('click', (e) => {
          const features = map.queryRenderedFeatures(e.point, { layers: ['floor1-extrude', 'floor2-extrude', 'map-poi-points'] });
          if (!features || !features.length) return;
          const f = features[0];
          let coords, title;
          if (f.layer.id === 'map-poi-points') {
            coords = f.geometry.coordinates;
            // derive title from properties (first key/value pair)
            const p = f.properties || {};
            title = Object.keys(p).length ? (Object.keys(p)[0] + (p[Object.keys(p)[0]] ? ': ' + p[Object.keys(p)[0]] : '')) : 'Point';
          } else {
            // polygon feature -> get centroid to anchor popup
            coords = centroidOfPolygon(f.geometry.coordinates) || e.lngLat;
            title = (f.properties && (f.properties.name || f.properties.label || ('Room'))) || 'Room';
          }
          // popup
          new maplibregl.Popup({ offset: [0, -10] })
            .setLngLat(coords)
            .setHTML('<strong>' + title + '</strong>')
            .addTo(map);

          // highlight polygon boundary briefly
          const geom = (f.layer.id === 'map-poi-points') ? null : { type: 'Feature', geometry: f.geometry, properties: { height: f.properties.height, base: f.properties.base } };
          if (geom) {
            map.getSource('hover-highlight').setData({ type: 'FeatureCollection', features: [geom] });
            // clear after 3s
            setTimeout(() => { map.getSource('hover-highlight').setData({ type: 'FeatureCollection', features: [] }); }, 3000);
          }
        });

        // change cursor to pointer when hovering clickable layers
        ['floor1-extrude', 'floor2-extrude', 'map-poi-points'].forEach(layerId => {
          map.on('mouseenter', layerId, () => map.getCanvas().style.cursor = 'pointer');
          map.on('mouseleave', layerId, () => map.getCanvas().style.cursor = '');
        });

        // Fit to building area (compute bbox of all polygon coordinates)
        try {
          const allCoords = [];
          [floor1Polys, floor2Polys, MAP].forEach(fc => {
            (fc.features || []).forEach(f => {
              if (!f.geometry) return;
              if (f.geometry.type === 'Polygon') {
                (f.geometry.coordinates[0] || []).forEach(c => allCoords.push(c));
              } else if (f.geometry.type === 'Point') {
                allCoords.push(f.geometry.coordinates);
              } else if (f.geometry.type === 'LineString') {
                (f.geometry.coordinates || []).forEach(c => allCoords.push(c));
              }
            });
          });
          if (allCoords.length) {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            allCoords.forEach(c => { const x = c[0], y = c[1]; if (x < minX) minX = x; if (y < minY) minY = y; if (x > maxX) maxX = x; if (y > maxY) maxY = y; });
            map.fitBounds([[minX, minY], [maxX, maxY]], { padding: 80, maxZoom: 19, duration: 1200 });
          }
        } catch (e) { console.warn('fitBounds failed', e); }

        // expose for search
        window._MAP_GEO = { mapPoints: MAP, floor1Polys, floor2Polys, floor1Points, floor2Points };

      }); // map.on('load')

      // -----------------------------
      // UI bindings: floor toggles
      // -----------------------------
      document.getElementById('btnF1').addEventListener('click', () => {
        if (!map) return;
        if (map.getLayer('floor1-extrude')) map.setLayoutProperty('floor1-extrude', 'visibility', 'visible');
        if (map.getLayer('floor1-labels')) map.setLayoutProperty('floor1-labels', 'visibility', 'visible');
        if (map.getLayer('floor2-extrude')) map.setLayoutProperty('floor2-extrude', 'visibility', 'none');
        if (map.getLayer('floor2-labels')) map.setLayoutProperty('floor2-labels', 'visibility', 'none');
      });
      document.getElementById('btnF2').addEventListener('click', () => {
        if (!map) return;
        if (map.getLayer('floor1-extrude')) map.setLayoutProperty('floor1-extrude', 'visibility', 'none');
        if (map.getLayer('floor1-labels')) map.setLayoutProperty('floor1-labels', 'visibility', 'none');
        if (map.getLayer('floor2-extrude')) map.setLayoutProperty('floor2-extrude', 'visibility', 'visible');
        if (map.getLayer('floor2-labels')) map.setLayoutProperty('floor2-labels', 'visibility', 'visible');
      });
      document.getElementById('btnBoth').addEventListener('click', () => {
        if (!map) return;
        if (map.getLayer('floor1-extrude')) map.setLayoutProperty('floor1-extrude', 'visibility', 'visible');
        if (map.getLayer('floor1-labels')) map.setLayoutProperty('floor1-labels', 'visibility', 'visible');
        if (map.getLayer('floor2-extrude')) map.setLayoutProperty('floor2-extrude', 'visibility', 'visible');
        if (map.getLayer('floor2-labels')) map.setLayoutProperty('floor2-labels', 'visibility', 'visible');
      });

      // pre-populate: show floor 1 by default
      document.getElementById('btnF1').click();
    } // end initializeMap()

    // -----------------------------
    // Search
    // -----------------------------
    const searchInput = document.getElementById('search');
    const resultsDiv = document.getElementById('results');

    function clearResults() { resultsDiv.innerHTML = ''; }

    function addResultItem(title, coords, snippet) {
      const d = document.createElement('div');
      d.className = 'result';
      d.innerHTML = '<strong>' + title + '</strong>' + (snippet ? '<div style="color:#555;font-size:12px;margin-top:4px;">' + snippet + '</div>' : '');
      d.onclick = () => {
        map.flyTo({ center: coords, zoom: 19, duration: 800 });
        new maplibregl.Popup({ offset: [0, -12] }).setLngLat(coords).setHTML('<b>' + title + '</b>' + (snippet ? '<br>' + snippet : '')).addTo(map);
      };
      resultsDiv.appendChild(d);
    }

    function searchQuery(q) {
      q = (q || '').trim().toLowerCase();
      clearResults();
      if (!q) return;
      // Search points in MAP
      (window._MAP_GEO.mapPoints.features || []).forEach(f => {
        if (!f.properties || !f.geometry) return;
        if (f.geometry.type !== 'Point') return;
        const text = JSON.stringify(f.properties).toLowerCase();
        if (text.indexOf(q) !== -1) {
          const title = Object.keys(f.properties)[0] || f.properties.name || 'Point';
          addResultItem(title, f.geometry.coordinates, JSON.stringify(f.properties));
        }
      });
      // Search floor polygons (floor1 and floor2)
      ['floor1Polys', 'floor2Polys'].forEach(sourceKey => {
        const fc = window._MAP_GEO && window._MAP_GEO[sourceKey];
        if (!fc) return;
        (fc.features || []).forEach(f => {
          const name = (f.properties && (f.properties.name || f.properties.label)) || '';
          if (name && name.toLowerCase().indexOf(q) !== -1) {
            const c = centroidOfPolygon(f.geometry.coordinates);
            addResultItem(name, c, 'Floor: ' + (f.properties.floor || (sourceKey === 'floor2Polys' ? 2 : 1)));
          }
        });
      });
      // if no results show message
      if (!resultsDiv.children.length) {
        resultsDiv.innerHTML = '<div style="padding:8px;color:#666">No results</div>';
      }
    }

    let debounceTimer = null;
    searchInput.addEventListener('input', (e) => {
      const v = e.target.value;
      if (debounceTimer) clearTimeout(debounceTimer);
      debounceTimer = setTimeout(() => searchQuery(v), 200);
    });

  </script>
</body>

</html>