<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PDA College 3D Map ‚Äî 2 floors</title>
  <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
  <style>
    html,
    body {
      height: 100%;
      margin: 0;
      font-family: Arial, Helvetica, sans-serif
    }

    #map {
      position: absolute;
      inset: 0
    }

    #controls {
      position: absolute;
      left: 12px;
      top: 12px;
      z-index: 3;
      background: #fff;
      border-radius: 8px;
      padding: 10px;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.12);
      min-width: 260px;
      max-width: 90vw;
    }

    .btn {
      display: inline-block;
      padding: 8px 10px;
      margin: 3px;
      border-radius: 6px;
      border: 0;
      cursor: pointer;
      font-size: 13px;
      white-space: nowrap;
    }

    .btn.primary {
      background: #0d6efd;
      color: #fff
    }

    .btn.ghost {
      background: #f1f3f5;
      color: #222
    }

    .floor-buttons {
      display: flex;
      gap: 6px;
      align-items: center;
      flex-wrap: wrap;
    }

    input[type="search"] {
      width: 100%;
      padding: 7px;
      border-radius: 6px;
      border: 1px solid #ddd;
      margin-top: 8px;
      box-sizing: border-box;
    }

    #results {
      max-height: 220px;
      overflow: auto;
      margin-top: 8px
    }

    .result {
      padding: 8px;
      border-radius: 6px;
      margin: 6px 0;
      background: #fafafa;
      cursor: pointer
    }

    .result:hover {
      background: #f0f8ff
    }

    #legend {
      margin-top: 8px;
      font-size: 13px
    }

    #legend .row {
      display: flex;
      gap: 8px;
      align-items: center;
      margin: 6px 0
    }

    .sw {
      width: 18px;
      height: 12px;
      border-radius: 3px;
      display: inline-block
    }

    .navigate-btn {
      background: #28a745;
      color: white;
      border: none;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
      margin-left: 8px;
    }

    .navigate-btn:hover {
      background: #218838;
    }

    .collapse-toggle {
      background: #6c757d;
      color: white;
      border: none;
      padding: 6px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      width: 100%;
      margin-top: 8px;
      text-align: center;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .collapse-toggle:hover {
      background: #5a6268;
    }

    .collapsible-section {
      overflow: hidden;
      transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
    }

    .collapsible-section.collapsed {
      max-height: 0 !important;
      opacity: 0;
      margin: 0;
      padding: 0;
    }

    .arrow {
      transition: transform 0.3s ease;
      font-size: 14px;
    }

    .arrow.rotated {
      transform: rotate(180deg);
    }

    /* Mobile Responsive Styles */
    @media (max-width: 768px) {
      #controls {
        left: 8px;
        top: 8px;
        right: 8px;
        padding: 8px;
        min-width: auto;
        max-width: none;
      }

      .floor-buttons {
        justify-content: space-between;
      }

      .btn {
        padding: 10px 8px;
        margin: 2px;
        font-size: 11px;
        flex: 1;
        min-width: 0;
      }

      input[type="search"] {
        padding: 10px;
        font-size: 14px;
      }

      #results {
        max-height: 150px;
        font-size: 13px;
      }

      .result {
        padding: 10px 8px;
      }

      #legend {
        font-size: 11px;
      }

      #legend .row {
        gap: 6px;
        margin: 4px 0;
      }

      .navigate-btn {
        padding: 6px 10px;
        font-size: 10px;
        margin-left: 4px;
      }
    }

    @media (max-width: 480px) {
      #controls {
        left: 4px;
        top: 4px;
        right: 4px;
        padding: 6px;
      }

      .btn {
        padding: 8px 4px;
        font-size: 10px;
      }

      input[type="search"] {
        padding: 8px;
        font-size: 13px;
        margin-top: 6px;
      }

      #results {
        max-height: 120px;
        font-size: 12px;
      }

      .result {
        padding: 8px 6px;
        margin: 4px 0;
      }

      #legend {
        font-size: 10px;
        margin-top: 6px;
      }

      .sw {
        width: 14px;
        height: 10px;
      }

      .navigate-btn {
        padding: 5px 8px;
        font-size: 9px;
      }
    }
  </style>
</head>

<body>
  <div id="controls">
    <div class="floor-buttons">
      <button id="btnF1" class="btn primary">Floor 1</button>
      <button id="btnF2" class="btn" style="background:#33a02c;color:#fff">Floor 2</button>
      <button id="btnBoth" class="btn" style="background:#20c997;color:#fff">Show Both</button>
    </div>

    <button id="btnLocation" class="btn" style="background:#007bff;color:#fff;width:100%;margin-top:8px">üìç Get My
      Location</button>

    <button class="collapse-toggle" id="toggleSearch">
      <span>üîç Search</span>
      <span class="arrow">‚ñº</span>
    </button>

    <div class="collapsible-section" id="searchSection">
      <input id="search" type="search" placeholder="Search rooms / points (e.g. LH-15, Cloud Computing)" />
      <div id="results"></div>
    </div>
  </div>

  <div id="map"></div>

  <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
  <script>
    // -----------------------------
    // Fetch GeoJSON files
    // -----------------------------
    let MAP = null;
    let FLOOR1 = null;
    let FLOOR2 = null;

    // Load all GeoJSON files
    Promise.all([
      fetch('map.geojson').then(r => r.json()),
      fetch('map2.geojson').then(r => r.json()),
      fetch('map1.geojson').then(r => r.json())
    ]).then(([mapData, floor1Data, floor2Data]) => {
      MAP = mapData;
      FLOOR1 = floor1Data;
      FLOOR2 = floor2Data;
      initializeMap();
    }).catch(err => {
      console.error('Error loading GeoJSON files:', err);
      alert('Failed to load map data. Please ensure map.geojson, map1.geojson, and map2.geojson files exist.');
    });

    // -----------------------------
    // Utility helpers
    // -----------------------------
    // compute a simple centroid from polygon rings (average of ring coordinates)
    function centroidOfPolygon(poly) {
      // poly: [ [ [lon,lat], ... ] ] (first ring)
      const ring = poly && poly[0] ? poly[0] : [];
      if (!ring.length) return null;
      let sumX = 0, sumY = 0;
      ring.forEach(pt => { sumX += pt[0]; sumY += pt[1]; });
      return [sumX / ring.length, sumY / ring.length];
    }

    // make a point feature for each polygon (for labels & flyTo)
    function polygonCentroidPoints(fc, nameProp = 'name', altitudeOffset = 0) {
      const pts = { type: 'FeatureCollection', features: [] };
      fc.features.forEach((f, idx) => {
        if (!f.geometry) return;
        if (f.geometry.type !== 'Polygon') return;
        const c = centroidOfPolygon(f.geometry.coordinates);
        const label = (f.properties && (f.properties[nameProp] || f.properties.label || f.properties.name)) || ('room-' + idx);
        pts.features.push({
          type: 'Feature',
          geometry: { type: 'Point', coordinates: c },
          properties: { label, source_index: idx, original_props: f.properties || {}, altitude: altitudeOffset }
        });
      });
      return pts;
    }

    // Merge polygon features into a single geojson (and ensure each has a 'height' & 'floor' property)
    function prepareFloorPolys(fc, floorNumber) {
      const out = { type: 'FeatureCollection', features: [] };
      (fc.features || []).forEach(f => {
        const clone = JSON.parse(JSON.stringify(f));
        if (!clone.properties) clone.properties = {};
        // set uniform heights (Option A)
        if (floorNumber === 1) {
          clone.properties.floor = 1;
          clone.properties.height = 5;         // top
          clone.properties.base = 0;           // base
        } else {
          clone.properties.floor = 2;
          clone.properties.height = 10;        // top
          clone.properties.base = 5;           // base
        }
        out.features.push(clone);
      });
      return out;
    }

    // -----------------------------
    // Navigation & User Location
    // -----------------------------
    let userLocationMarker = null;
    let userLocation = null;
    let navigationRoute = null;
    let watchId = null;

    // Simple routing: draw a line from user location to destination
    function createRoute(from, to) {
      return {
        type: 'Feature',
        geometry: {
          type: 'LineString',
          coordinates: [from, to]
        },
        properties: {}
      };
    }

    function startNavigation(destinationCoords, destinationName) {
      if (!userLocation) {
        alert('Please get your location first by clicking "üìç Get My Location"');
        return;
      }

      const mapInstance = window._MAP_INSTANCE;
      if (!mapInstance) return;

      // Create navigation route
      navigationRoute = createRoute(userLocation, destinationCoords);

      // Add or update navigation route layer
      if (mapInstance.getSource('navigation-route')) {
        mapInstance.getSource('navigation-route').setData(navigationRoute);
      } else {
        mapInstance.addSource('navigation-route', {
          type: 'geojson',
          data: navigationRoute
        });

        mapInstance.addLayer({
          id: 'navigation-route',
          type: 'line',
          source: 'navigation-route',
          paint: {
            'line-color': '#FF0000',
            'line-width': 4,
            'line-opacity': 0.8
          }
        });
      }

      // Fly to show the route
      const bounds = [
        [Math.min(userLocation[0], destinationCoords[0]), Math.min(userLocation[1], destinationCoords[1])],
        [Math.max(userLocation[0], destinationCoords[0]), Math.max(userLocation[1], destinationCoords[1])]
      ];
      mapInstance.fitBounds(bounds, { padding: 100, duration: 1000 });

      // Show navigation popup
      new maplibregl.Popup({ closeButton: true })
        .setLngLat(destinationCoords)
        .setHTML(`<b>Navigation to ${destinationName}</b><br>Follow the red line`)
        .addTo(mapInstance);
    }

    function clearNavigation() {
      const mapInstance = window._MAP_INSTANCE;
      if (!mapInstance) return;

      if (mapInstance.getSource('navigation-route')) {
        mapInstance.getSource('navigation-route').setData({
          type: 'FeatureCollection',
          features: []
        });
      }
    }

    function updateUserLocation(position) {
      const { latitude, longitude, accuracy } = position.coords;
      userLocation = [longitude, latitude];

      const mapInstance = window._MAP_INSTANCE;
      if (!mapInstance) return;

      // Remove previous marker
      if (userLocationMarker) {
        userLocationMarker.remove();
      }

      // Create user location marker
      const el = document.createElement('div');
      el.style.cssText = 'width: 20px; height: 20px; background: #4285F4; border: 3px solid white; border-radius: 50%; box-shadow: 0 2px 6px rgba(0,0,0,0.3);';

      userLocationMarker = new maplibregl.Marker({ element: el })
        .setLngLat([longitude, latitude])
        .addTo(mapInstance);

      // Fly to user location
      mapInstance.flyTo({
        center: [longitude, latitude],
        zoom: 19,
        duration: 1000
      });

      // Show location info
      new maplibregl.Popup({ offset: [0, -15], closeButton: false })
        .setLngLat([longitude, latitude])
        .setHTML(`<b>Your Location</b><br>Accuracy: ¬±${Math.round(accuracy)}m`)
        .addTo(mapInstance);
    }

    function getUserLocation() {
      if (!navigator.geolocation) {
        alert('Geolocation is not supported by your browser');
        return;
      }

      const btn = document.getElementById('btnLocation');
      btn.disabled = true;
      btn.textContent = '‚è≥ Getting location...';

      navigator.geolocation.getCurrentPosition(
        (position) => {
          updateUserLocation(position);
          btn.disabled = false;
          btn.textContent = 'üìç Location Active';
          btn.style.background = '#28a745';

          // Watch for position updates
          if (watchId) {
            navigator.geolocation.clearWatch(watchId);
          }
          watchId = navigator.geolocation.watchPosition(updateUserLocation, null, {
            enableHighAccuracy: true,
            maximumAge: 5000
          });
        },
        (error) => {
          btn.disabled = false;
          btn.textContent = 'üìç Get My Location';
          btn.style.background = '#007bff';

          let errorMsg = 'Unable to get your location';
          if (error.code === error.PERMISSION_DENIED) {
            errorMsg = 'Location permission denied. Please enable location access.';
          } else if (error.code === error.POSITION_UNAVAILABLE) {
            errorMsg = 'Location information unavailable.';
          } else if (error.code === error.TIMEOUT) {
            errorMsg = 'Location request timed out.';
          }
          alert(errorMsg);
        },
        { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
      );
    }

    // -----------------------------
    // Map initialization
    // -----------------------------
    function initializeMap() {
      const map = new maplibregl.Map({
        container: 'map',
        style: {
          version: 8,
          sources: {
            'osm-tiles': {
              type: 'raster',
              tiles: [
                'https://a.tile.openstreetmap.org/{z}/{x}/{y}.png',
                'https://b.tile.openstreetmap.org/{z}/{x}/{y}.png',
                'https://c.tile.openstreetmap.org/{z}/{x}/{y}.png'
              ],
              tileSize: 256
            }
          },
          layers: [{ id: 'osm-tiles', type: 'raster', source: 'osm-tiles' }]
        },
        center: [76.8342, 17.3154],
        zoom: 18,
        pitch: 60,
        bearing: -20
      });

      map.on('load', () => {
        // prepare floor GeoJSONs
        const floor1Polys = prepareFloorPolys(FLOOR1, 1);
        const floor2Polys = prepareFloorPolys(FLOOR2, 2);

        // polygon centroids for labels
        const floor1Points = polygonCentroidPoints(floor1Polys, 'name', 0);
        const floor2Points = polygonCentroidPoints(floor2Polys, 'name', 5);

        // add sources
        map.addSource('map-points', { type: 'geojson', data: MAP }); // raw points + lines
        map.addSource('floor1-polys', { type: 'geojson', data: floor1Polys });
        map.addSource('floor2-polys', { type: 'geojson', data: floor2Polys });
        map.addSource('floor1-points', { type: 'geojson', data: floor1Points });
        map.addSource('floor2-points', { type: 'geojson', data: floor2Points });

        // add outline lines from MAP (LineString features)
        map.addLayer({
          id: 'outlines',
          type: 'line',
          source: 'map-points',
          filter: ['==', ['geometry-type'], 'LineString'],
          paint: { 'line-color': '#003f7f', 'line-width': 2, 'line-opacity': 0.9 }
        });

        // Floor 1 extrusions
        map.addLayer({
          id: 'floor1-extrude',
          type: 'fill-extrusion',
          source: 'floor1-polys',
          paint: {
            'fill-extrusion-color': '#1f78b4',
            'fill-extrusion-height': ['get', 'height'],
            'fill-extrusion-base': ['get', 'base'],
            'fill-extrusion-opacity': 0.95
          }
        });

        // Floor 2 extrusions (hidden initially)
        map.addLayer({
          id: 'floor2-extrude',
          type: 'fill-extrusion',
          source: 'floor2-polys',
          layout: { visibility: 'none' },
          paint: {
            'fill-extrusion-color': '#33a02c',
            'fill-extrusion-height': ['get', 'height'],
            'fill-extrusion-base': ['get', 'base'],
            'fill-extrusion-opacity': 0.95
          }
        });

        // labels for floor1 (from centroid points)
        map.addLayer({
          id: 'floor1-labels',
          type: 'symbol',
          source: 'floor1-points',
          layout: {
            'text-field': ['coalesce', ['get', 'label'], ''],
            'text-size': 12,
            'text-anchor': 'top',
            'text-offset': [0, 1.0]
          },
          paint: { 'text-color': '#fff', 'text-halo-color': '#000', 'text-halo-width': 1 }
        });

        // labels for floor2 (hidden initially)
        map.addLayer({
          id: 'floor2-labels',
          type: 'symbol',
          source: 'floor2-points',
          layout: {
            'text-field': ['coalesce', ['get', 'label'], ''],
            'text-size': 12,
            'text-anchor': 'top',
            'text-offset': [0, 1.0],
            'visibility': 'none',
            'symbol-z-order': 'auto'
          },
          paint: {
            'text-color': '#fff',
            'text-halo-color': '#000',
            'text-halo-width': 1,
            'text-translate': [0, -100]
          }
        });

        // points from MAP (original loose POIs)
        map.addLayer({
          id: 'map-poi-points',
          type: 'circle',
          source: 'map-points',
          filter: ['==', ['geometry-type'], 'Point'],
          paint: { 'circle-radius': 5, 'circle-color': '#ff7f00', 'circle-stroke-color': '#fff', 'circle-stroke-width': 1.5 }
        });

        // clickable highlight layer (single feature highlight)
        map.addSource('hover-highlight', { type: 'geojson', data: { type: 'FeatureCollection', features: [] } });
        map.addLayer({
          id: 'hover-highlight-fill',
          type: 'fill-extrusion',
          source: 'hover-highlight',
          paint: {
            'fill-extrusion-color': '#ff0000',
            'fill-extrusion-height': ['get', 'height'],
            'fill-extrusion-base': ['get', 'base'],
            'fill-extrusion-opacity': 0.6
          }
        });

        // bind interactivity: clicking on extrusions shows popup
        map.on('click', (e) => {
          const features = map.queryRenderedFeatures(e.point, { layers: ['floor1-extrude', 'floor2-extrude', 'map-poi-points'] });
          if (!features || !features.length) return;
          const f = features[0];
          let coords, title;
          if (f.layer.id === 'map-poi-points') {
            coords = f.geometry.coordinates;
            // derive title from properties (first key/value pair)
            const p = f.properties || {};
            title = Object.keys(p).length ? (Object.keys(p)[0] + (p[Object.keys(p)[0]] ? ': ' + p[Object.keys(p)[0]] : '')) : 'Point';
          } else {
            // polygon feature -> get centroid to anchor popup
            coords = centroidOfPolygon(f.geometry.coordinates) || e.lngLat;
            title = (f.properties && (f.properties.name || f.properties.label || ('Room'))) || 'Room';
          }
          // popup
          new maplibregl.Popup({ offset: [0, -10] })
            .setLngLat(coords)
            .setHTML('<strong>' + title + '</strong>')
            .addTo(map);

          // highlight polygon boundary briefly
          const geom = (f.layer.id === 'map-poi-points') ? null : { type: 'Feature', geometry: f.geometry, properties: { height: f.properties.height, base: f.properties.base } };
          if (geom) {
            map.getSource('hover-highlight').setData({ type: 'FeatureCollection', features: [geom] });
            // clear after 3s
            setTimeout(() => { map.getSource('hover-highlight').setData({ type: 'FeatureCollection', features: [] }); }, 3000);
          }
        });

        // change cursor to pointer when hovering clickable layers
        ['floor1-extrude', 'floor2-extrude', 'map-poi-points'].forEach(layerId => {
          map.on('mouseenter', layerId, () => map.getCanvas().style.cursor = 'pointer');
          map.on('mouseleave', layerId, () => map.getCanvas().style.cursor = '');
        });

        // Fit to building area (compute bbox of all polygon coordinates)
        try {
          const allCoords = [];
          [floor1Polys, floor2Polys, MAP].forEach(fc => {
            (fc.features || []).forEach(f => {
              if (!f.geometry) return;
              if (f.geometry.type === 'Polygon') {
                (f.geometry.coordinates[0] || []).forEach(c => allCoords.push(c));
              } else if (f.geometry.type === 'Point') {
                allCoords.push(f.geometry.coordinates);
              } else if (f.geometry.type === 'LineString') {
                (f.geometry.coordinates || []).forEach(c => allCoords.push(c));
              }
            });
          });
          if (allCoords.length) {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            allCoords.forEach(c => { const x = c[0], y = c[1]; if (x < minX) minX = x; if (y < minY) minY = y; if (x > maxX) maxX = x; if (y > maxY) maxY = y; });
            map.fitBounds([[minX, minY], [maxX, maxY]], { padding: 80, maxZoom: 19, duration: 1200 });
          }
        } catch (e) { console.warn('fitBounds failed', e); }

        // expose for search
        window._MAP_GEO = { mapPoints: MAP, floor1Polys, floor2Polys, floor1Points, floor2Points };
        window._MAP_INSTANCE = map; // expose map instance for search highlight

      }); // map.on('load')

      // -----------------------------
      // UI bindings: floor toggles
      // -----------------------------
      document.getElementById('btnF1').addEventListener('click', () => {
        if (!map) return;
        if (map.getLayer('floor1-extrude')) map.setLayoutProperty('floor1-extrude', 'visibility', 'visible');
        if (map.getLayer('floor1-labels')) map.setLayoutProperty('floor1-labels', 'visibility', 'visible');
        if (map.getLayer('floor2-extrude')) map.setLayoutProperty('floor2-extrude', 'visibility', 'none');
        if (map.getLayer('floor2-labels')) map.setLayoutProperty('floor2-labels', 'visibility', 'none');
      });
      document.getElementById('btnF2').addEventListener('click', () => {
        if (!map) return;
        if (map.getLayer('floor1-extrude')) map.setLayoutProperty('floor1-extrude', 'visibility', 'none');
        if (map.getLayer('floor1-labels')) map.setLayoutProperty('floor1-labels', 'visibility', 'none');
        if (map.getLayer('floor2-extrude')) map.setLayoutProperty('floor2-extrude', 'visibility', 'visible');
        if (map.getLayer('floor2-labels')) map.setLayoutProperty('floor2-labels', 'visibility', 'visible');
      });
      document.getElementById('btnBoth').addEventListener('click', () => {
        if (!map) return;
        if (map.getLayer('floor1-extrude')) map.setLayoutProperty('floor1-extrude', 'visibility', 'visible');
        if (map.getLayer('floor1-labels')) map.setLayoutProperty('floor1-labels', 'visibility', 'visible');
        if (map.getLayer('floor2-extrude')) map.setLayoutProperty('floor2-extrude', 'visibility', 'visible');
        if (map.getLayer('floor2-labels')) map.setLayoutProperty('floor2-labels', 'visibility', 'visible');
      });

      // pre-populate: show floor 1 by default
      document.getElementById('btnF1').click();
    } // end initializeMap()

    // -----------------------------
    // Search
    // -----------------------------
    const searchInput = document.getElementById('search');
    const resultsDiv = document.getElementById('results');

    function clearResults() { resultsDiv.innerHTML = ''; }

    function addResultItem(title, coords, snippet, featureGeometry, featureProps) {
      const d = document.createElement('div');
      d.className = 'result';

      const contentDiv = document.createElement('div');
      contentDiv.style.display = 'flex';
      contentDiv.style.justifyContent = 'space-between';
      contentDiv.style.alignItems = 'center';

      const textDiv = document.createElement('div');
      textDiv.innerHTML = '<strong>' + title + '</strong>' + (snippet ? '<div style="color:#555;font-size:12px;margin-top:4px;">' + snippet + '</div>' : '');

      const navBtn = document.createElement('button');
      navBtn.className = 'navigate-btn';
      navBtn.textContent = 'üß≠ Navigate';
      navBtn.onclick = (e) => {
        e.stopPropagation();
        clearNavigation();
        startNavigation(coords, title);
      };

      contentDiv.appendChild(textDiv);
      contentDiv.appendChild(navBtn);
      d.appendChild(contentDiv);

      d.onclick = () => {
        const mapInstance = window._MAP_INSTANCE;
        if (!mapInstance) return;

        clearNavigation();
        mapInstance.flyTo({ center: coords, zoom: 19, duration: 800 });
        new maplibregl.Popup({ offset: [0, -12] }).setLngLat(coords).setHTML('<b>' + title + '</b>' + (snippet ? '<br>' + snippet : '')).addTo(mapInstance);

        // Highlight the block if it's a polygon feature
        if (featureGeometry && featureGeometry.type === 'Polygon' && featureProps) {
          const highlightFeature = {
            type: 'Feature',
            geometry: featureGeometry,
            properties: {
              height: featureProps.height || 5,
              base: featureProps.base || 0
            }
          };
          mapInstance.getSource('hover-highlight').setData({ type: 'FeatureCollection', features: [highlightFeature] });

          // Clear highlight after 3 seconds
          setTimeout(() => {
            if (mapInstance.getSource('hover-highlight')) {
              mapInstance.getSource('hover-highlight').setData({ type: 'FeatureCollection', features: [] });
            }
          }, 3000);
        }
      };
      resultsDiv.appendChild(d);
    }

    function searchQuery(q) {
      q = (q || '').trim().toLowerCase();
      clearResults();
      if (!q) return;
      // Search points in MAP
      (window._MAP_GEO.mapPoints.features || []).forEach(f => {
        if (!f.properties || !f.geometry) return;
        if (f.geometry.type !== 'Point') return;
        const text = JSON.stringify(f.properties).toLowerCase();
        if (text.indexOf(q) !== -1) {
          const title = Object.keys(f.properties)[0] || f.properties.name || 'Point';
          addResultItem(title, f.geometry.coordinates, JSON.stringify(f.properties));
        }
      });
      // Search floor polygons (floor1 and floor2)
      ['floor1Polys', 'floor2Polys'].forEach(sourceKey => {
        const fc = window._MAP_GEO && window._MAP_GEO[sourceKey];
        if (!fc) return;
        (fc.features || []).forEach(f => {
          const name = (f.properties && (f.properties.name || f.properties.label)) || '';
          if (name && name.toLowerCase().indexOf(q) !== -1) {
            const c = centroidOfPolygon(f.geometry.coordinates);
            addResultItem(name, c, 'Floor: ' + (f.properties.floor || (sourceKey === 'floor2Polys' ? 2 : 1)), f.geometry, f.properties);
          }
        });
      });
      // if no results show message
      if (!resultsDiv.children.length) {
        resultsDiv.innerHTML = '<div style="padding:8px;color:#666">No results</div>';
      }
    }

    let debounceTimer = null;
    searchInput.addEventListener('input', (e) => {
      const v = e.target.value;
      if (debounceTimer) clearTimeout(debounceTimer);
      debounceTimer = setTimeout(() => searchQuery(v), 200);
    });

    // Location button event listener
    document.getElementById('btnLocation').addEventListener('click', getUserLocation);

    // Collapsible sections functionality
    function setupCollapsible(toggleId, sectionId) {
      const toggle = document.getElementById(toggleId);
      const section = document.getElementById(sectionId);
      const arrow = toggle.querySelector('.arrow');

      // Set initial max-height for smooth animation
      section.style.maxHeight = section.scrollHeight + 'px';

      toggle.addEventListener('click', () => {
        const isCollapsed = section.classList.contains('collapsed');

        if (isCollapsed) {
          section.classList.remove('collapsed');
          section.style.maxHeight = section.scrollHeight + 'px';
          arrow.classList.remove('rotated');
        } else {
          section.style.maxHeight = section.scrollHeight + 'px';
          // Force reflow
          section.offsetHeight;
          section.classList.add('collapsed');
          arrow.classList.add('rotated');
        }
      });

      // Update max-height when content changes
      const observer = new MutationObserver(() => {
        if (!section.classList.contains('collapsed')) {
          section.style.maxHeight = section.scrollHeight + 'px';
        }
      });

      observer.observe(section, { childList: true, subtree: true });
    }

    setupCollapsible('toggleSearch', 'searchSection');

  </script>
</body>

</html>